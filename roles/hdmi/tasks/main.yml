- name: Add user to video group for framebuffer access
  user:
    name: "{{ service_user }}"
    groups: video
    append: yes

- name: Create framebuffer devices if they don't exist
  shell: |
    # Create fb0 if missing (major=29, minor=0)
    if [ ! -e /dev/fb0 ]; then
      mknod /dev/fb0 c 29 0
      chgrp video /dev/fb0
      chmod 664 /dev/fb0
      echo "Created /dev/fb0"
    fi
    
    # Create fb1 if missing (major=29, minor=32) 
    if [ ! -e /dev/fb1 ]; then
      mknod /dev/fb1 c 29 32
      chgrp video /dev/fb1  
      chmod 664 /dev/fb1
      echo "Created /dev/fb1"
    fi
    
    # Verify both devices exist and show status
    ls -la /dev/fb* || echo "No framebuffer devices found"
  become: yes
  register: fb_creation_result

- name: Display framebuffer creation results
  debug:
    var: fb_creation_result.stdout_lines

- name: Create udev rule to ensure framebuffer devices persist
  copy:
    dest: /etc/udev/rules.d/99-framebuffer.rules
    content: |
      # Ensure framebuffer devices exist for dual HDMI setup
      KERNEL=="fb0", MODE="0664", GROUP="video"
      KERNEL=="fb1", MODE="0664", GROUP="video"
      
      # Create fb1 device if it doesn't exist automatically
      SUBSYSTEM=="graphics", KERNEL=="fb1", RUN+="/bin/mknod /dev/fb1 c 29 32", RUN+="/bin/chgrp video /dev/fb1", RUN+="/bin/chmod 664 /dev/fb1"
    mode: '0644'
  notify: reboot

- name: Create framebuffer setup script
  copy:
    dest: /usr/local/bin/setup-framebuffers.sh
    content: |
      #!/bin/bash
      # Force creation of framebuffer devices for dual HDMI
      
      # Wait for system to settle
      sleep 2
      
      # Create fb1 if it doesn't exist (for HDMI1)
      if [ ! -e /dev/fb1 ]; then
          echo "Creating /dev/fb1 for HDMI1"
          mknod /dev/fb1 c 29 32
          chgrp video /dev/fb1
          chmod 664 /dev/fb1
      fi
      
      # Ensure fb0 has correct permissions
      if [ -e /dev/fb0 ]; then
          chgrp video /dev/fb0
          chmod 664 /dev/fb0
      fi
      
      # Log status
      echo "Framebuffer devices status:"
      ls -la /dev/fb* 2>/dev/null || echo "No framebuffer devices found"
    mode: '0755'

- name: Create systemd service for framebuffer setup
  copy:
    dest: /etc/systemd/system/framebuffer-setup.service
    content: |
      [Unit]
      Description=Setup framebuffer devices for dual HDMI
      After=multi-user.target
      
      [Service]
      Type=oneshot
      ExecStart=/usr/local/bin/setup-framebuffers.sh
      RemainAfterExit=yes
      
      [Install]
      WantedBy=multi-user.target
    mode: '0644'
  notify: reboot

- name: Enable framebuffer setup service
  systemd:
    name: framebuffer-setup
    enabled: yes
    daemon_reload: yes

- name: Check for config.txt location
  stat:
    path: "{{ item }}"
  register: config_locations
  loop:
    - /boot/firmware/config.txt
    - /boot/config.txt

- name: Set boot config path
  set_fact:
    boot_config_path: "{{ item.item }}"
  loop: "{{ config_locations.results }}"
  when: item.stat.exists

- name: Disable vc4-kms-v3d overlay (prevents framebuffer)
  replace:
    path: "{{ boot_config_path }}"
    regexp: '^dtoverlay=vc4-kms-v3d$'
    replace: '#dtoverlay=vc4-kms-v3d'
  notify: reboot
  when: boot_config_path is defined

- name: Disable vc4-fkms-v3d overlay (prevents framebuffer)  
  replace:
    path: "{{ boot_config_path }}"
    regexp: '^dtoverlay=vc4-fkms-v3d$'
    replace: '#dtoverlay=vc4-fkms-v3d'
  notify: reboot
  when: boot_config_path is defined

- name: Remove existing HDMI configuration to avoid conflicts
  blockinfile:
    path: "{{ boot_config_path }}"
    marker: "# {mark} ANSIBLE MANAGED DUAL HDMI CONFIGURATION"
    state: absent
  when: boot_config_path is defined

- name: Configure single framebuffer with dual HDMI support
  blockinfile:
    path: "{{ boot_config_path }}"
    marker: "# {mark} ANSIBLE MANAGED DUAL HDMI CONFIGURATION"
    insertafter: EOF
    block: |
      
      # === SINGLE FRAMEBUFFER DUAL HDMI CONFIGURATION ===
      # Use modern VC4 driver with single framebuffer spanning both displays
      dtoverlay=vc4-fkms-v3d
      
      # Force both HDMI ports to be active
      hdmi_force_hotplug:0=1
      hdmi_force_hotplug:1=1
      
      # HDMI0 configuration (left display)
      hdmi_group:0=1
      hdmi_mode:0=16
      hdmi_drive:0=2
      
      # HDMI1 configuration (right display - slideshow target)
      hdmi_group:1=1
      hdmi_mode:1=16  
      hdmi_drive:1=2
      
      # Single framebuffer configuration
      framebuffer_width=3840
      framebuffer_height=1080
      
      # GPU memory for dual displays
      gpu_mem=128
      
      # Clean output
      disable_overscan=1
  notify: reboot
  when: boot_config_path is defined

- name: Verify boot configuration was applied
  shell: |
    echo "=== CURRENT BOOT CONFIG ==="
    grep -E "(hdmi_|max_framebuffers|gpu_mem)" {{ boot_config_path }} || echo "No HDMI config found"
    echo ""
    echo "=== CHECKING FOR VC4 OVERLAYS ==="
    grep -E "dtoverlay=vc4" {{ boot_config_path }} || echo "No VC4 overlays found"
  register: config_verification
  when: boot_config_path is defined

- name: Display boot configuration verification
  debug:
    var: config_verification.stdout_lines
  when: boot_config_path is defined

- name: Check for cmdline.txt location
  stat:
    path: "{{ item }}"
  register: cmdline_locations
  loop:
    - /boot/firmware/cmdline.txt
    - /boot/cmdline.txt

- name: Set boot cmdline path
  set_fact:
    boot_cmdline_path: "{{ item.item }}"
  loop: "{{ cmdline_locations.results }}"
  when: item.stat.exists

- name: Configure console output to fb0 and disable screen blanking
  shell: |
    if ! grep -q "consoleblank=0" {{ boot_cmdline_path }}; then
      sed -i 's/$/ consoleblank=0/' {{ boot_cmdline_path }}
    fi
    if ! grep -q "fbcon=map:0" {{ boot_cmdline_path }}; then
      sed -i 's/$/ fbcon=map:0/' {{ boot_cmdline_path }}
    fi
  notify: reboot
  when: boot_cmdline_path is defined