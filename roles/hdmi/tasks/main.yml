- name: Add user to video group for framebuffer access
  user:
    name: "{{ service_user }}"
    groups: video
    append: yes

- name: Create framebuffer devices if they don't exist
  shell: |
    # Create fb0 if missing (major=29, minor=0)
    if [ ! -e /dev/fb0 ]; then
      mknod /dev/fb0 c 29 0
      chgrp video /dev/fb0
      chmod 664 /dev/fb0
      echo "Created /dev/fb0"
    fi
    
    # Create fb1 if missing (major=29, minor=32) 
    if [ ! -e /dev/fb1 ]; then
      mknod /dev/fb1 c 29 32
      chgrp video /dev/fb1  
      chmod 664 /dev/fb1
      echo "Created /dev/fb1"
    fi
    
    # Verify both devices exist and show status
    ls -la /dev/fb* || echo "No framebuffer devices found"
  become: yes
  register: fb_creation_result

- name: Display framebuffer creation results
  debug:
    var: fb_creation_result.stdout_lines

- name: Create udev rule to ensure framebuffer devices persist
  copy:
    dest: /etc/udev/rules.d/99-framebuffer.rules
    content: |
      # Ensure framebuffer devices exist for dual HDMI setup
      KERNEL=="fb0", MODE="0664", GROUP="video"
      KERNEL=="fb1", MODE="0664", GROUP="video"
      
      # Create fb1 device if it doesn't exist automatically
      SUBSYSTEM=="graphics", KERNEL=="fb1", RUN+="/bin/mknod /dev/fb1 c 29 32", RUN+="/bin/chgrp video /dev/fb1", RUN+="/bin/chmod 664 /dev/fb1"
    mode: '0644'
  notify: reboot

- name: Check for config.txt location
  stat:
    path: "{{ item }}"
  register: config_locations
  loop:
    - /boot/firmware/config.txt
    - /boot/config.txt

- name: Set boot config path
  set_fact:
    boot_config_path: "{{ item.item }}"
  loop: "{{ config_locations.results }}"
  when: item.stat.exists

- name: Disable existing vc4-kms-v3d overlay (prevents separate framebuffers)
  lineinfile:
    path: "{{ boot_config_path }}"
    regexp: '^dtoverlay=vc4-kms-v3d'
    line: '#dtoverlay=vc4-kms-v3d'
  notify: reboot
  when: boot_config_path is defined

- name: Configure dual HDMI setup with separate framebuffers
  blockinfile:
    path: "{{ boot_config_path }}"
    marker: "# {mark} ANSIBLE MANAGED DUAL HDMI CONFIGURATION"
    block: |
      # Dual HDMI Configuration for slideshow system
      # Force both HDMI ports to be active and detected
      hdmi_force_hotplug:0=1
      hdmi_force_hotplug:1=1
      
      # HDMI0 (fb0) - Console/SSH access - 1920x1080
      hdmi_group:0=1
      hdmi_mode:0=16
      hdmi_drive:0=2
      
      # HDMI1 (fb1) - Slideshow display - 1920x1080  
      hdmi_group:1=1
      hdmi_mode:1=16
      hdmi_drive:1=2
      
      # Enable dual display mode
      max_framebuffers=2
      
      # Use legacy framebuffer driver (required for /dev/fb1 creation)
      dtoverlay=vc4-fkms-v3d
      framebuffer_width=1920
      framebuffer_height=1080
      
      # Ensure sufficient GPU memory for dual displays
      gpu_mem=128
      
      # Disable overscan for both displays
      disable_overscan=1
  notify: reboot
  when: boot_config_path is defined

- name: Check for cmdline.txt location
  stat:
    path: "{{ item }}"
  register: cmdline_locations
  loop:
    - /boot/firmware/cmdline.txt
    - /boot/cmdline.txt

- name: Set boot cmdline path
  set_fact:
    boot_cmdline_path: "{{ item.item }}"
  loop: "{{ cmdline_locations.results }}"
  when: item.stat.exists

- name: Configure console output to fb0 and disable screen blanking
  shell: |
    if ! grep -q "consoleblank=0" {{ boot_cmdline_path }}; then
      sed -i 's/$/ consoleblank=0/' {{ boot_cmdline_path }}
    fi
    if ! grep -q "fbcon=map:0" {{ boot_cmdline_path }}; then
      sed -i 's/$/ fbcon=map:0/' {{ boot_cmdline_path }}
    fi
  notify: reboot
  when: boot_cmdline_path is defined